/**

By Mohammad Mayyan, August 1st, 2022
This code reads three files:
  1- XX.smartTable    contains raw data generated by the smart dining table.
                      The table is assumed to have nothing placed on it during
                      the first 5 seconds. This period is used for computing the
                      tare values.
  2- XX.calibration   contains calibration values for the grid of load cells to
                      convert raw data into weights in grams
  3- XX.groundTruth   contains manually labeled ground truth for the moments at
                      which bites of food and beverage were put in mouth.
The code segments each image of weights into food containers (plate, cup, and
bowl), detects bites consumed from each food container, then evaluates the
detections against the ground truth moments.


Compilation:
make

Usage:
./smartDiningTable XXX.smartTable



*/



#ifndef __GRID_VIEWER_H__
#define __GRID_VIEWER_H__


#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h> /*FIX: used to be <wait.h>*/
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <ctype.h> // for isdigit()
#include <unistd.h> // for sleep(), access()
#include <math.h>
#include <stdbool.h>
#include <limits.h>
#include <float.h> /* DBL_EPSILON */


#define TABLE_DATA_FILE_EXTENSION ".smartTable"
#define CALIBRATION_VALUES_FILE_EXTENSION ".calibration"
#define GROUND_TRUTH_FILE_EXTENSION ".groundTruth"
#define NUMBER_OF_GRID_ROWS	7
#define NUMBER_OF_GRID_COLUMNS	11
#define	NUMBER_OF_GRID_SENSELS	NUMBER_OF_GRID_COLUMNS*NUMBER_OF_GRID_ROWS
#define TARE_CALIBRATION_ARRAY_LENGTH 51

int tareArray[NUMBER_OF_GRID_SENSELS];
double calibrationArray[NUMBER_OF_GRID_SENSELS];
int readingsArrayMatrix[NUMBER_OF_GRID_SENSELS][TARE_CALIBRATION_ARRAY_LENGTH];
FILE *fpt;
int64_t numberOfDataFrames;
int **DataFrames;
double **DataFramesInGrams;
int **retrievedGroundTruth;
bool groundTruthLoaded;







/*******************************************************************/
/************************ regions ********************************/
unsigned char Regions[NUMBER_OF_GRID_SENSELS];	/* segmentation image (value is region label, 0 => background) */
int countOfPixelsInRegions[NUMBER_OF_GRID_SENSELS]; /*number of cells in each region*/
double		  RegionWeight[NUMBER_OF_GRID_SENSELS];	/* total weight in each region */
double imageOfWeightsInGrams[NUMBER_OF_GRID_SENSELS];
#define	MIN_WEIGHT_TO_JOIN_REGION	(double)0.5		/* minimum weight of any sensel to be included in region */
void SegmentRegions(double *imageOfWeightsInGrams);
bool RegionGrow(
	double *image,			/* image data */
  unsigned char *labels,  /* segmentation labels */
  int ROWS,int COLS,      /* size of image */
  int r,int c,            /* pixel to paint from */
  int paint_over_label,   /* image label to paint over */
  int new_label,          /* image label for painting */
  int *indices,           /* output:  indices of pixels painted */
  int *count             /* output:  count of pixels painted */
	);

#define NUMBER_OF_OBJECTS_TO_TRACK 3
double **eatingProfile;
unsigned int eatingProfileIndx;
int **regionIndices; /*filled by SegmentRegions()*/
double **detectedWeights;
double **movingSTD;
int **detectionSpot;

#define DETECTION_ALGORITHM_WINDOW_SIZE 5
#define DETECTION_ALGORITHM_WINDOW_SIZE_FOR_STABILITY 5 /*5 seems to work better than 3*/
#define DETECTION_ALGORITHM_WINDOW_SIZE_FOR_STABILITY_UTENSIL 2
#define STD_THRESHOLD_FOR_STABILITY 0.15f
#define STD_THRESHOLD_FOR_CHANGE 0.4f
#define MIN_WEIGHT_TO_DETECT 0.5f


/************************************************************************/
/****** My Segmentation using moving circle object over the grid ********/
bool getRegionUnderObject(
	double *image,			/* image data */
  unsigned char *labels,  /* segmentation labels */
	int startAtColumn,      /* cup is on the right. Bowl is on the left */
	int stopAtColumn,       /* cup is on the right. Bowl is on the left */
  int objectDiameter,     /* object diameter in mm */
  int *indices,           /* output:  indices of pixels painted */
  int *count,             /* output:  count of pixels painted */
	int stepSize,					/* step size (mm) at which the center of plate is moved through iterations */
	unsigned char objectLabel
	);
bool moveObjectOverSensel(
	bool *binaryImage,			/* binary image */
  unsigned char *labels,  /* segmentation labels */
	int startAtColumn,      /* cup is on the right. Bowl is on the left */
	int stopAtColumn,       /* cup is on the right. Bowl is on the left */
  int objectDiameter,     /* object diameter in mm */
  int *indices,           /* output:  indices of pixels painted */
  int *count,             /* output:  count of pixels painted */
	int stepSize,						/* step size (mm) at which the center of plate is moved through iterations */
	int row,								/*coordinates of the sensel over which the object is moving */
	int col									/*coordinates of the sensel over which the object is moving */
);
#define PLATE_DIAMETER 190
#define CUP_DIAMETER 67
#define BOWL_DIAMETER 102
#define PLATE_SEGMENT_LABEL	1
#define CUP_SEGMENT_LABEL		2
#define BOWL_SEGMENT_LABEL	3
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
// circular footprint dishare
typedef struct
{
	int
	x, // origion X
	y; // origion Y
}Point;
typedef struct Dishware
{
	int r; // radius
	Point center;
} Dishware;
int ***senselOrigion; //senselOrigion
Point getOrigionOfSensel(int sensRow, int sensCol);
float distance(Point a, Point b );
#define SENSEL_SIDE_LENGTH_MM 50	// the mechanical dimention of the tile side in mm
#define SPACING_BETWEEN_ADJACENT_TILES_MM	1	// the mechanical spacing between adjacent tiles in mm
typedef enum
{
	U_S, // upper
	R_S, // right
	B_S, // bottom
	L_S, // left
} SenselSides;
bool isTouchingSide(
	const SenselSides side,
	const Point plateCenter,
	const Point so,
	const int gSS,
	const int dishRadius);




/****************** ground truth ***********************/
char groungTruthFullPathFileName[320];
typedef enum GROUND_TRUTH_LABELS
{
	GROUND_TRUTH_LABELS_NO_LABEL = 0,
	GROUND_TRUTH_LABELS_REMOVE_LABEL = 1,
	GROUND_TRUTH_LABELS_WEIGHT_ADDED = 2,
	GROUND_TRUTH_LABELS_WEIGHT_REMOVED = 3,
	GROUND_TRUTH_LABELS_BITE_PICKED_UP = 4,
	GROUND_TRUTH_LABELS_BITE_CONSUMED = 5,
	GROUND_TRUTH_LABELS_MASSBITE_PICKED_UP = 6,
	GROUND_TRUTH_LABELS_MASSBITE_CONSUMED = 7,
	GROUND_TRUTH_LABELS_DRINK_PICKED_UP = 8,
	GROUND_TRUTH_LABELS_DRINK_CONSUMED = 9,
	GROUND_TRUTH_LABELS_DRINK_RETURNED = 10,
	GROUND_TRUTH_LABELS_LENGTH,
} GROUND_TRUTH_LABELS;


#define WEIGHT_OF_UTENSIL 1.5f
#define WEIGHT_OF_UTENSIL_MARGIN 0.5f



/*************************************************************************/
/********************** computeF1Score *********************************/
/*************************************************************************/
#define SAMPLE_RATE_OF_THE_SYSTEM	10	// sps
#define WINDOW_SIZE_IN_SECONDS	10
#define WINDOW_SIZE_FOR_MATCHING SAMPLE_RATE_OF_THE_SYSTEM*WINDOW_SIZE_IN_SECONDS

#define	MAX_BITES	1000
#define	NOT_MATCHED	-99999	/* sentinel used during matching */
#define	NOT_COUNTED	-99998	/* bite outside evaluated range */
#define	CANNOT_BE_MATCHED	-99997

#define SQR(x)	((x)*(x))

void computeF1Score_Hoover(
double **computerDetectedWeights,
bool useConsumedBitesForGroundTruth,	// consumed = 1, picked up = 0
bool extendedOutput,										// yes = 1, no = 0
bool importantExtendedOutput										// yes = 1, no = 0
);

#define PLOT_SELECTION_LENGTH 4
float biteRate_spb[PLOT_SELECTION_LENGTH];
float totalWeightOfConsumedFood[PLOT_SELECTION_LENGTH];


void loadFiles(char const **files);
void processSegmentationAndBiteDetection(void);

#endif // __GRID_VIEWER_H__
